<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State of Matter Simulation</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.7);
            --accent-color: #38bdf8;
            --text-color: #f1f5f9;
            --grid-line: #334155;
            --slider-track: #475569;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .main-container {
            display: flex;
            flex: 1;
            height: 100%;
            padding: 1rem;
            gap: 1rem;
            box-sizing: border-box;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                overflow-y: auto;
            }
        }

        .panel {
            flex: 1;
            background: var(--card-bg);
            border-radius: 16px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .panel-header {
            padding: 1rem;
            font-weight: 600;
            font-size: 1.1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 1.5rem;
            background: linear-gradient(transparent, rgba(15, 23, 42, 0.9));
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        button {
            background: var(--accent-color);
            color: #0f172a;
            border: none;
            padding: 0.5rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: var(--slider-track);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--text-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        #state-label {
            font-size: 0.9rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .temperature-display {
            font-variant-numeric: tabular-nums;
            font-family: monospace;
        }

        select {
            background: rgba(30, 41, 59, 0.9);
            color: var(--text-color);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0.5rem;
            border-radius: 8px;
            font-size: 0.8rem;
            cursor: pointer;
            outline: none;
            font-family: inherit;
        }

        select:hover {
            background: rgba(45, 55, 72, 0.9);
        }

        .canvas-container {
            flex: 1;
            position: relative;
        }
    </style>
</head>

<body>

    <div class="main-container">
        <!-- Left: Simulation -->
        <section class="panel">
            <div class="panel-header">
                <span>Particle View</span>
                <span id="current-phase">SOLID</span>
            </div>
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
        </section>

        <!-- Right: Graph -->
        <section class="panel">
            <div class="panel-header">
                <span>Heating Curve</span>
                <span class="temperature-display"><span id="temp-val">0</span>°C</span>
            </div>
            <div class="canvas-container">
                <canvas id="graphCanvas"></canvas>
                <div class="controls-overlay">
                    <div class="control-row">
                        <span id="state-label">Heat Added</span>
                    </div>
                    <div class="control-row">
                        <button id="playBtn" type="button">Pause</button>
                        <button id="resetBtn" type="button">Reset</button>
                        <select id="speedSelect">
                            <option value="0.5">0.5x</option>
                            <option value="1" selected>1x</option>
                            <option value="1.5">1.5x</option>
                            <option value="2">2x</option>
                        </select>
                        <input type="range" id="heatSlider" min="0" max="100" value="0" step="0.1">
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script>
        /**
         * State of Matter Simulation
         * 
         * Physics Model:
         * - Time/Heat (t) ranges 0 -> 100
         * - Phases:
         *   0-20: Solid (Warming)
         *   20-40: Melting (Plateau)
         *   40-65: Liquid (Warming)
         *   65-85: Boiling (Plateau)
         *   85-100: Gas (Warming)
         */

        const N_PARTICLES = 100;
        const PARTICLE_RADIUS = 12;
        const CONTAINER_PADDING = 20;

        const PHASES = {
            SOLID: { name: 'Solid', color: '#3b82f6' },
            MELTING: { name: 'Melting', color: '#6366f1' },
            LIQUID: { name: 'Liquid', color: '#8b5cf6' },
            BOILING: { name: 'Boiling', color: '#d946ef' },
            GAS: { name: 'Gas', color: '#ef4444' }
        };

        // Physics Constants
        const GRAVITY = 0.5;
        const DAMPING = 0.98; // Friction

        class StateManager {
            constructor() {
                this.heat = 0; // 0 to 100
                this.isPlaying = true;
                this.temp = 0;
                this.phase = PHASES.SOLID;
                this.speedMultiplier = 1.0;
            }

            calculateState() {
                // Curve Logic matching rounded corners in graph
                // Corner radius r = 3 units

                let t = this.heat;

                if (t <= 17) {
                    this.phase = PHASES.SOLID;
                    // Linear from (0, -50) to (17, -7.5), slope 2.5
                    this.temp = -50 + 2.5 * t;
                } else if (t <= 23) {
                    this.phase = PHASES.MELTING;
                    // Quadratic bezier: (17, -7.5) -> (23, 0) with control (20, 0)
                    const progress = (t - 17) / 6;
                    const inv = 1 - progress;
                    this.temp = inv * inv * (-7.5) + 2 * inv * progress * 0 + progress * progress * 0;
                } else if (t <= 37) {
                    this.phase = PHASES.MELTING;
                    // Flat plateau at 0
                    this.temp = 0;
                } else if (t <= 43) {
                    this.phase = PHASES.LIQUID;
                    // Quadratic bezier: (37, 0) -> (43, 12) with control (40, 0)
                    const progress = (t - 37) / 6;
                    const inv = 1 - progress;
                    this.temp = inv * inv * 0 + 2 * inv * progress * 0 + progress * progress * 12;
                } else if (t <= 62) {
                    this.phase = PHASES.LIQUID;
                    // Linear from (43, 12) to (62, 88), slope 4
                    this.temp = 12 + 4 * (t - 43);
                } else if (t <= 68) {
                    this.phase = PHASES.BOILING;
                    // Quadratic bezier: (62, 88) -> (68, 100) with control (65, 100)
                    const progress = (t - 62) / 6;
                    const inv = 1 - progress;
                    this.temp = inv * inv * 88 + 2 * inv * progress * 100 + progress * progress * 100;
                } else if (t <= 82) {
                    this.phase = PHASES.BOILING;
                    // Flat plateau at 100
                    this.temp = 100;
                } else if (t <= 88) {
                    this.phase = PHASES.GAS;
                    // Quadratic bezier: (82, 100) -> (88, 110) with control (85, 100)
                    const progress = (t - 82) / 6;
                    const inv = 1 - progress;
                    this.temp = inv * inv * 100 + 2 * inv * progress * 100 + progress * progress * 110;
                } else {
                    this.phase = PHASES.GAS;
                    // Linear from (88, 110) to (100, 150), slope 10/3
                    this.temp = 110 + (10 / 3) * (t - 88);
                }

                document.getElementById('current-phase').textContent = this.phase.name;
                document.getElementById('temp-val').textContent = Math.round(this.temp);

                // Progress slider
                const slider = document.getElementById('heatSlider');
                if (document.activeElement !== slider) {
                    slider.value = this.heat;
                }
            }

            update() {
                if (this.isPlaying) {
                    // Base speed is halved (0.1 -> 0.05)
                    this.heat += 0.05 * this.speedMultiplier;
                    if (this.heat > 100) {
                        this.heat = 100;
                        this.isPlaying = false;
                        document.getElementById('playBtn').textContent = 'Play';
                    }
                    this.calculateState();
                }
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.baseX = x; // Lattice position
                this.baseY = y;
                this.radius = PARTICLE_RADIUS;
            }

            draw(ctx, color) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            update(width, height, state) {
                const t = state.heat;
                const phase = state.phase;

                // --- 1. Temperature-based Velocity (Energy) ---
                // Base energy increases with heat
                // Solid: Vibration around baseX/Y
                // Liquid/Gas: Velocity vector magnitude

                // --- Behavior Switching ---

                if (phase === PHASES.SOLID || (phase === PHASES.MELTING && Math.random() > (t - 20) / 20)) {
                    // LATTICE BEHAVIOR (Solid)
                    // Hooke's law restorative force to base position
                    const k = 0.1; // Spring constant
                    const ax = (this.baseX - this.x) * k;
                    const ay = (this.baseY - this.y) * k;

                    this.vx += ax;
                    this.vy += ay;

                    // Add vibration based on Temp
                    // Temp -50 to 0. Normalized 0 to 1 for this range.
                    let vib = 0;
                    if (state.temp <= 0) {
                        vib = (state.temp + 50) / 50; // 0 to 1
                    } else {
                        vib = 1;
                    }

                    this.vx += (Math.random() - 0.5) * vib * 1.5;
                    this.vy += (Math.random() - 0.5) * vib * 1.5;

                    this.vx *= 0.9; // Damping
                    this.vy *= 0.9;

                } else if (phase === PHASES.GAS || (phase === PHASES.BOILING && Math.random() < (t - 65) / 20)) {
                    // GAS BEHAVIOR
                    // No gravity, high speed, elastic bouncing

                    const speed = 1 + ((state.temp) / 150) * 8; // Speed scales with temp

                    // Normalize vel to speed
                    const currSpeed = Math.sqrt(this.vx ** 2 + this.vy ** 2) || 0.1;
                    if (currSpeed < speed) {
                        this.vx = (this.vx / currSpeed) * speed;
                        this.vy = (this.vy / currSpeed) * speed;
                    }

                    // Gravity is OFF

                } else {
                    // LIQUID BEHAVIOR
                    // Gravity ON, Weak interaction, semi-clumping

                    this.vy += GRAVITY;

                    // More damping in liquid
                    this.vx *= DAMPING;
                    this.vy *= DAMPING;

                    // Some random Brownian motion
                    let heatFactor = (state.temp - 0) / 100; // 0 to 1 scaling roughly
                    if (heatFactor < 0) heatFactor = 0.1;

                    this.vx += (Math.random() - 0.5) * 0.5 * (1 + heatFactor);
                    this.vy += (Math.random() - 0.5) * 0.5 * (1 + heatFactor);
                }

                // --- Position Update ---
                this.x += this.vx * state.speedMultiplier;
                this.y += this.vy * state.speedMultiplier;

                // --- Boundary Constraints (Circular) ---
                const centerX = width / 2;
                const centerY = height / 2;
                const containerRadius = Math.min(width, height) / 2 - CONTAINER_PADDING;

                const dx = this.x - centerX;
                const dy = this.y - centerY;
                const distFromCenter = Math.sqrt(dx * dx + dy * dy);

                if (distFromCenter > containerRadius - this.radius) {
                    // Calculate normal vector at collision point
                    const nx = dx / distFromCenter;
                    const ny = dy / distFromCenter;

                    // Position correction - push back inside
                    this.x = centerX + nx * (containerRadius - this.radius);
                    this.y = centerY + ny * (containerRadius - this.radius);

                    // Reflect velocity: v' = v - 2(v·n)n
                    const dotProduct = this.vx * nx + this.vy * ny;
                    this.vx = (this.vx - 2 * dotProduct * nx) * 0.8;
                    this.vy = (this.vy - 2 * dotProduct * ny) * 0.8;
                }
            }
        }

        // --- Initialization ---

        const simCanvas = document.getElementById('simCanvas');
        const graphCanvas = document.getElementById('graphCanvas');
        const simCtx = simCanvas.getContext('2d');
        const graphCtx = graphCanvas.getContext('2d');
        const stateManager = new StateManager();
        let particles = [];

        function initParticles(width, height) {
            particles = [];
            const rows = 10;
            const cols = 10;
            const startX = width / 2 - (cols * PARTICLE_RADIUS * 3) / 2;
            const containerRadius = Math.min(width, height) / 2 - CONTAINER_PADDING;
            const startY = height / 2 + containerRadius - (rows * PARTICLE_RADIUS * 3) - PARTICLE_RADIUS;

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    particles.push(new Particle(
                        startX + i * PARTICLE_RADIUS * 3,
                        startY + j * PARTICLE_RADIUS * 3
                    ));
                }
            }
        }

        function resize() {
            // Set resolution logic
            const panels = document.querySelectorAll('.panel');
            const p1 = panels[0].getBoundingClientRect();
            const p2 = panels[1].getBoundingClientRect();

            simCanvas.width = p1.width;
            simCanvas.height = p1.height - 50; // Subtract header

            graphCanvas.width = p2.width;
            graphCanvas.height = p2.height - 50;

            initParticles(simCanvas.width, simCanvas.height);
        }

        window.addEventListener('resize', resize);


        // --- Rendering ---

        function drawGraph(width, height, state) {
            graphCtx.clearRect(0, 0, width, height);

            const margin = 50;
            const w = width - margin * 2;
            const h = height - margin * 2;

            // Axes
            graphCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            graphCtx.moveTo(margin, margin); // Top Y
            graphCtx.lineTo(margin, height - margin); // Origin
            graphCtx.lineTo(width - margin, height - margin); // Right X
            graphCtx.stroke();

            // Labels
            graphCtx.fillStyle = 'rgba(255,255,255,0.6)';
            graphCtx.font = '12px Inter';
            graphCtx.fillText('Temp (°C)', margin - 40, margin - 10);
            graphCtx.fillText('Time / Heat', width - margin, height - margin + 20);

            // Chart coords map
            // X: 0->100 map to margin -> width-margin
            // Y: -50->150 map to height-margin -> margin

            function mapX(val) { return margin + (val / 100) * w; }
            function mapY(val) { return (height - margin) - ((val + 50) / 200) * h; }

            // Draw Curve Path with rounded corners
            graphCtx.strokeStyle = '#38bdf8';
            graphCtx.lineWidth = 4;
            graphCtx.lineJoin = 'round';
            graphCtx.lineCap = 'round';
            graphCtx.beginPath();

            const r = 3; // corner radius in graph units

            // Draw path with rounded corners
            // Start at (0, -50)
            graphCtx.moveTo(mapX(0), mapY(-50));

            // Line to before first corner: (17, -7.5)
            graphCtx.lineTo(mapX(17), mapY(-7.5));
            // Round corner to melting plateau: (17, -7.5) -> (23, 0) with control (20, 0)
            graphCtx.quadraticCurveTo(mapX(20), mapY(0), mapX(23), mapY(0));

            // Melting plateau to (37, 0)
            graphCtx.lineTo(mapX(37), mapY(0));
            // Round corner to liquid warming: (37, 0) -> (43, 12) with control (40, 0)
            graphCtx.quadraticCurveTo(mapX(40), mapY(0), mapX(43), mapY(12));

            // Line to before next corner: (62, 88)
            graphCtx.lineTo(mapX(62), mapY(88));
            // Round corner to boiling plateau: (62, 88) -> (68, 100) with control (65, 100)
            graphCtx.quadraticCurveTo(mapX(65), mapY(100), mapX(68), mapY(100));

            // Boiling plateau to (82, 100)
            graphCtx.lineTo(mapX(82), mapY(100));
            // Round corner to gas warming: (82, 100) -> (88, 110) with control (85, 100)
            graphCtx.quadraticCurveTo(mapX(85), mapY(100), mapX(88), mapY(110));

            // Line to end (100, 150)
            graphCtx.lineTo(mapX(100), mapY(150));

            graphCtx.stroke();

            // Draw Current Position Dot
            const cx = mapX(state.heat);
            const cy = mapY(state.temp);

            graphCtx.beginPath();
            graphCtx.arc(cx, cy, 8, 0, Math.PI * 2);
            graphCtx.fillStyle = '#fde047';
            graphCtx.fill();
            graphCtx.shadowColor = '#fde047';
            graphCtx.shadowBlur = 15;
            graphCtx.stroke();
        }

        function animate() {
            stateManager.update();

            // 1. Sim Render
            simCtx.clearRect(0, 0, simCanvas.width, simCanvas.height);

            // Container Circle
            const centerX = simCanvas.width / 2;
            const centerY = simCanvas.height / 2;
            const containerRadius = Math.min(simCanvas.width, simCanvas.height) / 2 - CONTAINER_PADDING;

            simCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            simCtx.lineWidth = 2;
            simCtx.beginPath();
            simCtx.arc(centerX, centerY, containerRadius, 0, Math.PI * 2);
            simCtx.stroke();

            // Particles
            particles.forEach(p => {
                p.update(simCanvas.width, simCanvas.height, stateManager);
                // Collision with other particles (Simple approach)
                // O(N^2) but N is small
                if (stateManager.heat > 20) { // Only calculate collisions if not solid (lattice handles separation)
                    for (let other of particles) {
                        if (p === other) continue;
                        const dx = other.x - p.x;
                        const dy = other.y - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = p.radius * 2;

                        if (dist < minDist) {
                            const angle = Math.atan2(dy, dx);
                            const force = 0.5;
                            p.vx -= Math.cos(angle) * force;
                            p.vy -= Math.sin(angle) * force;
                        }
                    }
                }

                p.draw(simCtx, stateManager.phase.color);
            });

            // 2. Graph Render
            drawGraph(graphCanvas.width, graphCanvas.height, stateManager);

            requestAnimationFrame(animate);
        }

        // --- Controls ---
        const playBtn = document.getElementById('playBtn');
        const resetBtn = document.getElementById('resetBtn');
        const heatSlider = document.getElementById('heatSlider');

        playBtn.addEventListener('click', () => {
            stateManager.isPlaying = !stateManager.isPlaying;
            playBtn.textContent = stateManager.isPlaying ? 'Pause' : 'Play';
        });

        resetBtn.addEventListener('click', () => {
            stateManager.heat = 0;
            stateManager.isPlaying = true; // Auto restart
            playBtn.textContent = 'Pause';
            initParticles(simCanvas.width, simCanvas.height);
        });

        heatSlider.addEventListener('input', (e) => {
            stateManager.isPlaying = false;
            playBtn.textContent = 'Play';
            stateManager.heat = parseFloat(e.target.value);
            stateManager.calculateState();
        });

        const speedSelect = document.getElementById('speedSelect');
        speedSelect.addEventListener('change', (e) => {
            stateManager.speedMultiplier = parseFloat(e.target.value);
        });

        // Boot
        setTimeout(() => {
            resize();
            animate();
        }, 100);

    </script>
</body>

</html>