<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Color Matching Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=National+Park:wght@200..800&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100svh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000000;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 390px;
            height: 667px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
        }
        @supports not (height: 100svh) {
            html, body {
                height: -webkit-fill-available;
            }
        }
        @media (min-width: 440px) {
            #game-container {
                width: 440px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        // Add SplashScene before the IonDatabase definition
        class SplashScene extends Phaser.Scene {
            constructor() {
                super({ key: 'SplashScene' });
            }

            preload() {
                // Add loading error handler
                this.load.on('loaderror', (fileObj) => {
                    console.error('Error loading asset:', fileObj.src);
                });

                // Add a loading complete handler
                this.load.on('complete', () => {
                    console.log('All assets loaded successfully');
                });

                // Show loading progress
                const progressBar = this.add.graphics();
                const progressBox = this.add.graphics();
                progressBox.fillStyle(0x222222, 0.8);
                progressBox.fillRect(
                    this.scale.width / 4,
                    this.scale.height / 2 - 15,
                    this.scale.width / 2,
                    30
                );

                this.load.on('progress', (value) => {
                    progressBar.clear();
                    progressBar.fillStyle(0x00ff00, 1);
                    progressBar.fillRect(
                        this.scale.width / 4,
                        this.scale.height / 2 - 15,
                        (this.scale.width / 2) * value,
                        30
                    );
                });

                // Try loading both PNG and SVG versions
                this.load.image('logo', 'images/logo_stacked.png');
                this.load.image('logo-svg', 'images/logo_stacked.svg');
                
                // Load the font using WebFontLoader
                this.load.script('webfont', 'https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js');
            }

            create() {
                // Clean up progress bar
                this.children.list
                    .filter(child => child instanceof Phaser.GameObjects.Graphics)
                    .forEach(child => child.destroy());

                // Load fonts before creating the elements
                WebFont.load({
                    google: {
                        families: ['National Park:400,700']
                    },
                    active: () => {
                        this.createSplashScreen();
                    }
                });
            }

            createSplashScreen() {
                // Create dark overlay
                this.add.rectangle(0, 0, this.scale.width, this.scale.height, 0x000000)
                    .setOrigin(0);

                // Try to add logo with error handling
                let logo;
                try {
                    // Try PNG first
                    logo = this.add.image(
                        this.scale.width / 2,
                        this.scale.height / 2 - 50,
                        'logo'
                    );
                } catch (error) {
                    console.log('Falling back to SVG version');
                    try {
                        // Fall back to SVG if PNG fails
                        logo = this.add.image(
                            this.scale.width / 2,
                            this.scale.height / 2 - 50,
                            'logo-svg'
                        );
                    } catch (error) {
                        console.error('Failed to load both logo versions');
                        // Create a text placeholder if both images fail
                        logo = this.add.text(
                            this.scale.width / 2,
                            this.scale.height / 2 - 50,
                            'Ion Matching Game',
                            {
                                fontFamily: 'National Park',
                                fontSize: '32px',
                                fill: '#ffffff',
                                fontWeight: '700'
                            }
                        );
                    }
                }

                logo.setOrigin(0.5);

                // Scale logo to fit nicely if it's an image
                if (logo instanceof Phaser.GameObjects.Image) {
                    const scale = Math.min(
                        (this.scale.width * 0.8) / logo.width,
                        (this.scale.height * 0.4) / logo.height
                    );
                    logo.setScale(scale);
                }

                // Create start button
                const buttonWidth = 200;
                const buttonHeight = 60;
                const button = this.add.rectangle(
                    this.scale.width / 2,
                    this.scale.height / 2 + 150,
                    buttonWidth,
                    buttonHeight,
                    0x4caf50
                ).setInteractive();

                const buttonText = this.add.text(
                    this.scale.width / 2,
                    this.scale.height / 2 + 150,
                    'Start',
                    {
                        fontFamily: 'National Park',
                        fontSize: '32px',
                        fill: '#ffffff',
                        fontWeight: '700'
                    }
                ).setOrigin(0.5);

                // Add hover effect
                button.on('pointerover', () => {
                    button.setFillStyle(0x66bb6a);
                });
                button.on('pointerout', () => {
                    button.setFillStyle(0x4caf50);
                });

                // Add click handler
                button.on('pointerdown', () => {
                    // Fade out effect
                    this.tweens.add({
                        targets: [logo, button, buttonText],
                        alpha: 0,
                        duration: 500,
                        ease: 'Power2',
                        onComplete: () => {
                            // Start the main game scene
                            this.scene.start('MainScene');
                        }
                    });
                });
            }
        }

        // Ion database and helper functions
        const IonDatabase = {
            cations: [
                { symbol: 'Na⁺', charge: 1 },
                { symbol: 'K⁺', charge: 1 },
                { symbol: 'Li⁺', charge: 1 },
                { symbol: 'Mg²⁺', charge: 2 },
                { symbol: 'Ca²⁺', charge: 2 },
                { symbol: 'Al³⁺', charge: 3 },
                { symbol: 'Fe²⁺', charge: 2 },
                { symbol: 'Fe³⁺', charge: 3 },
                { symbol: 'Ba²⁺', charge: 2 },
                { symbol: 'Ag⁺', charge: 1 },
                { symbol: 'NH₄⁺', charge: 1 }
            ],
            anions: [
                { symbol: 'OH⁻', charge: -1 },
                { symbol: 'Cl⁻', charge: -1 },
                { symbol: 'Br⁻', charge: -1 },
                { symbol: 'I⁻', charge: -1 },
                { symbol: 'F⁻', charge: -1 },
                { symbol: 'NO₃⁻', charge: -1 },
                { symbol: 'SO₄²⁻', charge: -2 },
                { symbol: 'CO₃²⁻', charge: -2 },
                { symbol: 'PO₄³⁻', charge: -3 },
                { symbol: 'HCO₃⁻', charge: -1 },
                { symbol: 'O²⁻', charge: -2 },
                { symbol: 'S²⁻', charge: -2 },
                { symbol: 'CH₃COO⁻', charge: -1 }
            ],
            compounds: {
                'Na⁺_OH⁻': 'Sodium hydroxide',
                'Na⁺_Cl⁻': 'Sodium chloride',
                'Na⁺_Br⁻': 'Sodium bromide',
                'Na⁺_I⁻': 'Sodium iodide',
                'Na⁺_F⁻': 'Sodium fluoride',
                'Na⁺_NO₃⁻': 'Sodium nitrate',
                'Na⁺_SO₄²⁻': 'Sodium sulfate',
                'Na⁺_CO₃²⁻': 'Sodium carbonate',
                'Na⁺_PO₄³⁻': 'Sodium phosphate',
                'Na⁺_HCO₃⁻': 'Sodium bicarbonate',
                'Na⁺_O²⁻': 'Sodium oxide',
                'Na⁺_S²⁻': 'Sodium sulfide',
                'Na⁺_CH₃COO⁻': 'Sodium acetate',
                'K⁺_OH⁻': 'Potassium hydroxide',
                'K⁺_Cl⁻': 'Potassium chloride',
                'K⁺_Br⁻': 'Potassium bromide',
                'K⁺_I⁻': 'Potassium iodide',
                'K⁺_F⁻': 'Potassium fluoride',
                'K⁺_NO₃⁻': 'Potassium nitrate',
                'K⁺_SO₄²⁻': 'Potassium sulfate',
                'K⁺_CO₃²⁻': 'Potassium carbonate',
                'K⁺_PO₄³⁻': 'Potassium phosphate',
                'K⁺_HCO₃⁻': 'Potassium bicarbonate',
                'K⁺_O²⁻': 'Potassium oxide',
                'K⁺_S²⁻': 'Potassium sulfide',
                'K⁺_CH₃COO⁻': 'Potassium acetate',
                'Li⁺_OH⁻': 'Lithium hydroxide',
                'Li⁺_Cl⁻': 'Lithium chloride',
                'Li⁺_Br⁻': 'Lithium bromide',
                'Li⁺_I⁻': 'Lithium iodide',
                'Li⁺_F⁻': 'Lithium fluoride',
                'Li⁺_NO₃⁻': 'Lithium nitrate',
                'Li⁺_SO₄²⁻': 'Lithium sulfate',
                'Li⁺_CO₃²⁻': 'Lithium carbonate',
                'Li⁺_PO₄³⁻': 'Lithium phosphate',
                'Li⁺_O²⁻': 'Lithium oxide',
                'Li⁺_S²⁻': 'Lithium sulfide',
                'Li⁺_CH₃COO⁻': 'Lithium acetate',
                'Mg²⁺_OH⁻': 'Magnesium hydroxide',
                'Mg²⁺_Cl⁻': 'Magnesium chloride',
                'Mg²⁺_Br⁻': 'Magnesium bromide',
                'Mg²⁺_I⁻': 'Magnesium iodide',
                'Mg²⁺_F⁻': 'Magnesium fluoride',
                'Mg²⁺_NO₃⁻': 'Magnesium nitrate',
                'Mg²⁺_SO₄²⁻': 'Magnesium sulfate',
                'Mg²⁺_CO₃²⁻': 'Magnesium carbonate',
                'Mg²⁺_PO₄³⁻': 'Magnesium phosphate',
                'Mg²⁺_O²⁻': 'Magnesium oxide',
                'Mg²⁺_S²⁻': 'Magnesium sulfide',
                'Mg²⁺_CH₃COO⁻': 'Magnesium acetate',
                'Ca²⁺_OH⁻': 'Calcium hydroxide',
                'Ca²⁺_Cl⁻': 'Calcium chloride',
                'Ca²⁺_Br⁻': 'Calcium bromide',
                'Ca²⁺_I⁻': 'Calcium iodide',
                'Ca²⁺_F⁻': 'Calcium fluoride',
                'Ca²⁺_NO₃⁻': 'Calcium nitrate',
                'Ca²⁺_SO₄²⁻': 'Calcium sulfate',
                'Ca²⁺_CO₃²⁻': 'Calcium carbonate',
                'Ca²⁺_PO₄³⁻': 'Calcium phosphate',
                'Ca²⁺_O²⁻': 'Calcium oxide',
                'Ca²⁺_S²⁻': 'Calcium sulfide',
                'Ca²⁺_CH₃COO⁻': 'Calcium acetate',
                'Al³⁺_OH⁻': 'Aluminium hydroxide',
                'Al³⁺_Cl⁻': 'Aluminium chloride',
                'Al³⁺_Br⁻': 'Aluminium bromide',
                'Al³⁺_I⁻': 'Aluminium iodide',
                'Al³⁺_F⁻': 'Aluminium fluoride',
                'Al³⁺_NO₃⁻': 'Aluminium nitrate',
                'Al³⁺_SO₄²⁻': 'Aluminium sulfate',
                'Al³⁺_PO₄³⁻': 'Aluminium phosphate',
                'Al³⁺_O²⁻': 'Aluminium oxide',
                'Al³⁺_S²⁻': 'Aluminium sulfide',
                'Al³⁺_CH₃COO⁻': 'Aluminium acetate',
                'Fe²⁺_OH⁻': 'Iron (II) hydroxide',
                'Fe²⁺_Cl⁻': 'Iron (II) chloride',
                'Fe²⁺_Br⁻': 'Iron (II) bromide',
                'Fe²⁺_I⁻': 'Iron (II) iodide',
                'Fe²⁺_F⁻': 'Iron (II) fluoride',
                'Fe²⁺_NO₃⁻': 'Iron (II) nitrate',
                'Fe²⁺_SO₄²⁻': 'Iron (II) sulfate',
                'Fe²⁺_CO₃²⁻': 'Iron (II) carbonate',
                'Fe²⁺_PO₄³⁻': 'Iron (II) phosphate',
                'Fe²⁺_O²⁻': 'Iron (II) oxide',
                'Fe²⁺_S²⁻': 'Iron (II) sulfide',
                'Fe²⁺_CH₃COO⁻': 'Iron (II) acetate',
                'Fe³⁺_OH⁻': 'Iron (III) hydroxide',
                'Fe³⁺_Cl⁻': 'Iron (III) chloride',
                'Fe³⁺_Br⁻': 'Iron (III) bromide',
                'Fe³⁺_I⁻': 'Iron (III) iodide',
                'Fe³⁺_F⁻': 'Iron (III) fluoride',
                'Fe³⁺_NO₃⁻': 'Iron (III) nitrate',
                'Fe³⁺_SO₄²⁻': 'Iron (III) sulfate',
                'Fe³⁺_PO₄³⁻': 'Iron (III) phosphate',
                'Fe³⁺_O²⁻': 'Iron (III) oxide',
                'Fe³⁺_S²⁻': 'Iron (III) sulfide',
                'Fe³⁺_CH₃COO⁻': 'Iron (III) acetate',
                'Ba²⁺_OH⁻': 'Barium hydroxide',
                'Ba²⁺_Cl⁻': 'Barium chloride',
                'Ba²⁺_Br⁻': 'Barium bromide',
                'Ba²⁺_I⁻': 'Barium iodide',
                'Ba²⁺_F⁻': 'Barium fluoride',
                'Ba²⁺_NO₃⁻': 'Barium nitrate',
                'Ba²⁺_SO₄²⁻': 'Barium sulfate',
                'Ba²⁺_CO₃²⁻': 'Barium carbonate',
                'Ba²⁺_PO₄³⁻': 'Barium phosphate',
                'Ba²⁺_O²⁻': 'Barium oxide',
                'Ba²⁺_S²⁻': 'Barium sulfide',
                'Ba²⁺_CH₃COO⁻': 'Barium acetate',
                'Ag⁺_Cl⁻': 'Silver chloride',
                'Ag⁺_Br⁻': 'Silver bromide',
                'Ag⁺_I⁻': 'Silver iodide',
                'Ag⁺_F⁻': 'Silver fluoride',
                'Ag⁺_NO₃⁻': 'Silver nitrate',
                'Ag⁺_SO₄²⁻': 'Silver sulfate',
                'Ag⁺_CO₃²⁻': 'Silver carbonate',
                'Ag⁺_PO₄³⁻': 'Silver phosphate',
                'Ag⁺_O²⁻': 'Silver oxide',
                'Ag⁺_S²⁻': 'Silver sulfide',
                'Ag⁺_CH₃COO⁻': 'Silver acetate',
                'NH₄⁺_OH⁻': 'Ammonium hydroxide',
                'NH₄⁺_Cl⁻': 'Ammonium chloride',
                'NH₄⁺_Br⁻': 'Ammonium bromide',
                'NH₄⁺_I⁻': 'Ammonium iodide',
                'NH₄⁺_F⁻': 'Ammonium fluoride',
                'NH₄⁺_NO₃⁻': 'Ammonium nitrate',
                'NH₄⁺_SO₄²⁻': 'Ammonium sulfate',
                'NH₄⁺_CO₃²⁻': 'Ammonium carbonate',
                'NH₄⁺_PO₄³⁻': 'Ammonium phosphate',
                'NH₄⁺_HCO₃⁻': 'Ammonium bicarbonate',
                'NH₄⁺_O²⁻': 'Ammonium oxide',
                'NH₄⁺_S²⁻': 'Ammonium sulfide',
                'NH₄⁺_CH₃COO⁻': 'Ammonium acetate'
            },
            
            // Helper function to check if ions can form a neutral compound
            canFormNeutralCompound: function(ion1, ion2, count1 = 1, count2 = 1) {
                const totalCharge = (ion1.charge * count1) + (ion2.charge * count2);
                return totalCharge === 0;
            },
            
            // Helper function to get compound name from ions
            getCompoundName: function(cation, anion, cationCount = 1, anionCount = 1) {
                // For simple 1:1 compounds
                if (cationCount === 1 && anionCount === 1) {
                    const key = `${cation.symbol}_${anion.symbol}`;
                    return this.compounds[key] || null;
                }
                
                // For intermediate patterns
                const pattern = `${cation.symbol}${cationCount > 1 ? cationCount : ''}_${anion.symbol}${anionCount > 1 ? anionCount : ''}`;
                return this.compounds[pattern] || null;
            },
            
            // Helper function to check intermediate patterns
            checkIntermediatePattern: function(ions) {
                if (ions.length !== 3) return false;
                
                // Get unique ions and their counts
                const ionCounts = {};
                ions.forEach(ion => {
                    const key = `${ion.symbol}_${ion.charge}`;
                    ionCounts[key] = (ionCounts[key] || 0) + 1;
                });
                
                // Get unique ions
                const uniqueIons = ions.filter((ion, index, self) =>
                    index === self.findIndex(i => i.symbol === ion.symbol && i.charge === ion.charge)
                );
                
                if (uniqueIons.length !== 2) return false;
                
                const [ion1, ion2] = uniqueIons;
                const count1 = ionCounts[`${ion1.symbol}_${ion1.charge}`];
                const count2 = ionCounts[`${ion2.symbol}_${ion2.charge}`];
                
                // Check for valid intermediate patterns (1:2, 2:1, 1:3, 3:1)
                return this.canFormNeutralCompound(ion1, ion2, count1, count2);
            },
            
            // Helper function to get random ions that can form a compound
            getRandomCompoundPair: function() {
                const cation = this.cations[Math.floor(Math.random() * this.cations.length)];
                // Filter anions that can potentially form a neutral compound
                const possibleAnions = this.anions.filter(anion => {
                    const cationMultiple = Math.abs(anion.charge);
                    const anionMultiple = Math.abs(cation.charge);
                    return this.canFormNeutralCompound(cation, anion, anionMultiple, cationMultiple);
                });
                const anion = possibleAnions[Math.floor(Math.random() * possibleAnions.length)];
                return { cation, anion };
            },
            
            // Helper function to get required ion counts for neutral compound
            getRequiredCounts: function(cation, anion) {
                const cationCharge = Math.abs(cation.charge);
                const anionCharge = Math.abs(anion.charge);
                // Find the least common multiple
                const lcm = (cationCharge * anionCharge) / this.gcd(cationCharge, anionCharge);
                return {
                    cationCount: lcm / cationCharge,
                    anionCount: lcm / anionCharge
                };
            },
            
            // Helper function to calculate GCD
            gcd: function(a, b) {
                while (b !== 0) {
                    const temp = b;
                    b = a % b;
                    a = temp;
                }
                return a;
            },
            
            // Helper function to check advanced patterns
            checkAdvancedPattern: function(ions) {
                if (ions.length !== 5) return false;
                
                // Get unique ions and their counts
                const ionCounts = {};
                ions.forEach(ion => {
                    const key = `${ion.symbol}_${ion.charge}`;
                    ionCounts[key] = (ionCounts[key] || 0) + 1;
                });
                
                // Get unique ions
                const uniqueIons = ions.filter((ion, index, self) =>
                    index === self.findIndex(i => i.symbol === ion.symbol && i.charge === ion.charge)
                );
                
                if (uniqueIons.length !== 2) return false;
                
                const [ion1, ion2] = uniqueIons;
                const count1 = ionCounts[`${ion1.symbol}_${ion1.charge}`];
                const count2 = ionCounts[`${ion2.symbol}_${ion2.charge}`];
                
                // Check for valid advanced patterns (2:3, 3:2)
                return this.canFormNeutralCompound(ion1, ion2, count1, count2);
            }
        };

        // Flow Validator class to handle valid selection sequences
        class FlowValidator {
            constructor() {
                // Define all valid flows
                this.validFlows = [
                    // Simple 1:1 patterns (2 tiles)
                    ['+1', '-1'],
                    ['-1', '+1'],
                    ['+2', '-2'],
                    ['-2', '+2'],
                    ['+3', '-3'],
                    ['-3', '+3'],
                    
                    // Intermediate 1:2 or 2:1 patterns (3-4 tiles)
                    ['+2', '-1', '-1'],
                    ['-1', '+2', '-1'],
                    ['-1', '-1', '+2'],
                    ['+1', '+1', '-2'],
                    ['-2', '+1', '+1'],
                    ['+1', '-2', '+1'],
                    ['+3', '-1', '-1', '-1'],
                    ['-1', '+3', '-1', '-1'],
                    ['-1', '-1', '+3', '-1'],
                    ['-1', '-1', '-1', '+3'],
                    ['-3', '+1', '+1', '+1'],
                    ['+1', '-3', '+1', '+1'],
                    ['+1', '+1', '-3', '+1'],
                    ['+1', '+1', '+1', '-3'],
                    
                    // Advanced 2:3 or 3:2 patterns (5 tiles)
                    ['+3', '+3', '-2', '-2', '-2'],
                    ['+3', '-2', '+3', '-2', '-2'],
                    ['+3', '-2', '-2', '+3', '-2'],
                    ['+3', '-2', '-2', '-2', '+3'],
                    ['-2', '+3', '+3', '-2', '-2'],
                    ['-2', '+3', '-2', '+3', '-2'],
                    ['-2', '+3', '-2', '-2', '+3'],
                    ['-2', '-2', '+3', '+3', '-2'],
                    ['-2', '-2', '+3', '-2', '+3'],
                    ['-2', '-2', '-2', '+3', '+3'],
                    ['-3', '-3', '+2', '+2', '+2'],
                    ['-3', '+2', '-3', '+2', '+2'],
                    ['-3', '+2', '+2', '-3', '+2'],
                    ['-3', '+2', '+2', '+2', '-3'],
                    ['+2', '-3', '-3', '+2', '+2'],
                    ['+2', '-3', '+2', '-3', '+2'],
                    ['+2', '-3', '+2', '+2', '-3'],
                    ['+2', '+2', '-3', '-3', '+2'],
                    ['+2', '+2', '-3', '+2', '-3'],
                    ['+2', '+2', '+2', '-3', '-3']
                ];
                
                this.currentSequence = [];
                this.validPrefixes = new Set();
                this.initializeValidPrefixes();
            }
            
            initializeValidPrefixes() {
                // Create a set of all valid prefixes from the flows
                this.validFlows.forEach(flow => {
                    for (let i = 0; i < flow.length; i++) {
                        this.validPrefixes.add(flow.slice(0, i + 1).join(','));
                    }
                });
            }
            
            addSelection(charge) {
                const chargeStr = charge > 0 ? `+${charge}` : `${charge}`;
                this.currentSequence.push(chargeStr);
                return this.isValidPrefix();
            }
            
            isValidPrefix() {
                return this.validPrefixes.has(this.currentSequence.join(','));
            }
            
            isCompleteFlow() {
                return this.validFlows.some(flow => 
                    flow.join(',') === this.currentSequence.join(',')
                );
            }
            
            getExpectedNextCharges() {
                const currentPrefix = this.currentSequence.join(',');
                const possibleNext = new Set();
                
                this.validFlows.forEach(flow => {
                    const flowPrefix = flow.slice(0, this.currentSequence.length).join(',');
                    if (flowPrefix === currentPrefix && flow.length > this.currentSequence.length) {
                        possibleNext.add(flow[this.currentSequence.length]);
                    }
                });
                
                return Array.from(possibleNext).map(charge => parseInt(charge));
            }
            
            reset() {
                this.currentSequence = [];
            }
        }

        class MainScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MainScene' });
                this.gridSize = 5;
                this.tileGraphics = [];
                this.tiles = [];
                this.selectedTiles = [];
                this.isProcessingMatch = false;
                this.compoundType = null;
                
                // Base dimensions
                this.baseWidth = 390;
                this.baseHeight = 667;
                
                // Game timer values
                this.gameTime = 90;
                this.timeRemaining = this.gameTime;
                
                // Font settings
                this.fontFamily = 'National Park';
                this.fontWeightBold = '700';
                this.fontWeightNormal = '400';
                this.baseFontSize = 20; // Base font size for normal symbols
                this.minFontSize = 14;  // Minimum font size for long symbols
                
                // Ion settings
                this.tileColor = 0xffffff;
                this.currentCompoundPair = null;
                this.shadowColor = 0x000000;
                this.highlightColor = 0x00ffff;
                this.matchColor = 0xaaffc3;
                this.score = 0;
                
                // Game state
                this.gameState = {
                    isSelecting: false,
                    currentSelection: [],
                    expectedIonCount: 0,
                    expectedCharges: [],
                    isPaused: false
                };
                
                // Add flow validator
                this.flowValidator = new FlowValidator();
            }

            preload() {
                // Load the font using WebFontLoader
                this.load.script('webfont', 'https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js');
            }

            create() {
                // Load fonts before creating the game elements
                WebFont.load({
                    google: {
                        families: ['National Park:400,700']
                    },
                    active: () => {
                        this.initializeGame();
                    }
                });
            }
            
            initializeGame() {
                // Reset game state
                this.score = 0;
                this.timeRemaining = this.gameTime;
                this.isProcessingMatch = false;
                this.selectedTiles = [];
                this.gameState.isPaused = false;
                
                // Clear any existing timers
                if (this.gameTimer) {
                    this.gameTimer.remove();
                    this.gameTimer = null;
                }
                
                // Get current game dimensions
                this.gameWidth = this.scale.width;
                this.gameHeight = this.scale.height;
                
                // Set the game's background
                this.cameras.main.setBackgroundColor('#000000');
                
                // Create graphics group for tiles
                this.tileGroup = this.add.group();
                
                // Calculate grid size to fill width with appropriate padding
                const gridPadding = Math.floor(this.gameWidth * 0.05);
                const availableWidth = this.gameWidth - (gridPadding * 2);
                const cellPadding = Math.floor(availableWidth * 0.025);
                
                // Calculate tile size to fit 5 tiles with padding between them
                this.tileSize = (availableWidth - (cellPadding * (this.gridSize - 1))) / this.gridSize;
                this.padding = cellPadding;
                
                // Create tiles
                this.createGrid(gridPadding);
                
                // Add score display centered at top
                this.scoreText = this.add.text(
                    this.gameWidth / 2,
                    20,
                    'Score: 0',
                    { 
                        fontFamily: this.fontFamily,
                        fontSize: '24px',
                        fill: '#ffffff',
                        fontWeight: this.fontWeightBold
                    }
                ).setOrigin(0.5);
                
                // Create timer display and progress bar
                this.createTimer();
                
                // Create pause button
                this.createPauseButton();
                
                // Start the game timer
                this.startGameTimer();
            }
            
            createTimer() {
                const timerGroupY = 60; // Position below score
                
                // Add timer text
                this.timerText = this.add.text(
                    this.gameWidth / 2 - 100, // Position to the left of progress bar
                    timerGroupY,
                    '90s',
                    { 
                        fontFamily: this.fontFamily,
                        fontSize: '20px',
                        fill: '#ffffff',
                        fontWeight: this.fontWeightBold
                    }
                ).setOrigin(0.5);
                
                // Calculate progress bar width and position
                const barWidth = 180;
                const barHeight = 14;
                const radius = barHeight / 2;
                const totalWidth = barWidth + this.timerText.width + 8; // Total width including spacing
                const startX = (this.gameWidth - totalWidth) / 2 + this.timerText.width + 8; // Center the group
                
                // Store bar dimensions for updates
                this.barStartX = startX;
                this.barWidth = barWidth;
                this.barHeight = barHeight;
                this.barY = timerGroupY - radius;
                this.barRadius = radius;
                
                // Create container for progress bar components
                this.timerBarContainer = this.add.container(0, 0);
                
                // Create background components
                this.bgLeft = this.add.circle(startX + radius, timerGroupY, radius, 0x444444);
                this.bgRight = this.add.circle(startX + barWidth - radius, timerGroupY, radius, 0x444444);
                this.bgMiddle = this.add.rectangle(
                    startX + radius,
                    timerGroupY,
                    barWidth - barHeight,
                    barHeight,
                    0x444444
                );
                
                // Create fill components
                this.timerBarLeft = this.add.circle(startX + radius, timerGroupY, radius, 0x00ffff);
                this.timerBarRight = this.add.circle(startX + barWidth - radius, timerGroupY, radius, 0x00ffff);
                this.timerBarMiddle = this.add.rectangle(
                    startX + radius,
                    timerGroupY,
                    barWidth - barHeight,
                    barHeight,
                    0x00ffff
                );
                
                // Add all components to container
                this.timerBarContainer.add([
                    this.bgLeft, this.bgMiddle, this.bgRight,
                    this.timerBarLeft, this.timerBarMiddle, this.timerBarRight
                ]);
                
                // Initialize progress
                this.updateTimerBar(1);
            }
            
            updateTimerBar(progress) {
                if (progress < 0) progress = 0;
                if (progress > 1) progress = 1;
                
                const fillWidth = (this.barWidth - this.barHeight) * progress;
                const centerX = this.barStartX + this.barRadius;
                
                // Update fill color based on remaining time
                let fillColor = 0x00ffff;
                if (progress <= 0.33) {
                    fillColor = 0xff3300; // Red
                } else if (progress <= 0.11) {
                    fillColor = 0xff9900; // Orange
                }
                
                // Update middle rectangle
                this.timerBarMiddle.setSize(fillWidth, this.barHeight);
                this.timerBarMiddle.setPosition(centerX + fillWidth/2, this.barY + this.barRadius);
                this.timerBarMiddle.setFillStyle(fillColor);
                
                // Update right semicircle visibility and color
                this.timerBarRight.setFillStyle(fillColor);
                this.timerBarRight.setVisible(progress > 0);
                
                // Update left semicircle color
                this.timerBarLeft.setFillStyle(fillColor);
                
                // Position right semicircle
                if (progress > 0) {
                    const rightX = this.barStartX + fillWidth + this.barRadius;
                    this.timerBarRight.setPosition(rightX, this.barY + this.barRadius);
                }
                
                // Update background components
                this.bgMiddle.setSize(this.barWidth - this.barHeight, this.barHeight);
                this.bgMiddle.setPosition(centerX + (this.barWidth - this.barHeight)/2, this.barY + this.barRadius);
                this.bgRight.setPosition(this.barStartX + this.barWidth - this.barRadius, this.barY + this.barRadius);
            }
            
            startGameTimer() {
                // Clear any existing timers
                if (this.gameTimer) {
                    this.gameTimer.remove();
                }
                
                // Reset time remaining
                this.timeRemaining = this.gameTime;
                
                // Create a clock for the game timer
                this.gameTimer = this.time.addEvent({
                    delay: 1000,
                    callback: this.updateTimer,
                    callbackScope: this,
                    loop: true
                });
                
                // Create a clock for smooth progress bar updates
                this.progressTimer = this.time.addEvent({
                    delay: 16, // Update at ~60fps
                    callback: this.updateProgressBar,
                    callbackScope: this,
                    loop: true
                });
                
                // Store the start time
                this.timerStartTime = this.time.now;
            }
            
            updateTimer() {
                if (this.gameState.isPaused) return;
                
                // Update timer text
                this.timerText.setText(`${this.timeRemaining}s`);
                
                // End game when timer runs out
                if (this.timeRemaining <= 0) {
                    this.gameTimer.remove();
                    this.progressTimer.remove();
                    this.gameOver();
                }
            }
            
            updateProgressBar() {
                if (this.gameState.isPaused) return;
                
                // Calculate remaining time as a percentage
                const elapsed = (this.time.now - this.timerStartTime) / 1000;
                const remaining = Math.max(0, this.gameTime - elapsed);
                this.timeRemaining = Math.ceil(remaining);
                
                // Update progress bar
                this.updateTimerBar(remaining / this.gameTime);
            }
            
            gameOver() {
                // Clear any existing timers
                if (this.gameTimer) {
                    this.gameTimer.remove();
                    this.gameTimer = null;
                }
                if (this.progressTimer) {
                    this.progressTimer.remove();
                    this.progressTimer = null;
                }
                
                // Create semi-transparent overlay (50% opacity)
                const overlay = this.add.rectangle(
                    0, 0, 
                    this.gameWidth, 
                    this.gameHeight, 
                    0x000000, 
                    0.5
                ).setOrigin(0);
                
                // Display game over message
                const gameOverText = this.add.text(
                    this.gameWidth / 2,
                    this.gameHeight / 2,
                    'Game Over',
                    { 
                        fontFamily: this.fontFamily,
                        fontSize: '40px',
                        fill: '#ffffff',
                        fontWeight: this.fontWeightBold
                    }
                ).setOrigin(0.5);
                
                // Display final score
                const finalScoreText = this.add.text(
                    this.gameWidth / 2,
                    this.gameHeight / 2 + 50,
                    `Final Score: ${this.score}`,
                    { 
                        fontFamily: this.fontFamily,
                        fontSize: '30px',
                        fill: '#ffffff',
                        fontWeight: this.fontWeightNormal
                    }
                ).setOrigin(0.5);
                
                // Create start over button
                const startOverButton = this.add.rectangle(
                    this.gameWidth / 2,
                    this.gameHeight / 2 + 120,
                    180,
                    50,
                    0x4caf50
                ).setInteractive();
                
                const startOverText = this.add.text(
                    this.gameWidth / 2,
                    this.gameHeight / 2 + 120,
                    'Start Over',
                    { 
                        fontFamily: this.fontFamily,
                        fontSize: '24px',
                        fill: '#ffffff',
                        fontWeight: this.fontWeightBold
                    }
                ).setOrigin(0.5);
                
                // Add hover effect to start over button
                startOverButton.on('pointerover', () => {
                    startOverButton.setFillStyle(0x66bb6a);
                });
                startOverButton.on('pointerout', () => {
                    startOverButton.setFillStyle(0x4caf50);
                });
                
                // Add click handler to go to splash screen
                startOverButton.on('pointerdown', () => {
                    // Clean up game over elements
                    overlay.destroy();
                    gameOverText.destroy();
                    finalScoreText.destroy();
                    startOverButton.destroy();
                    startOverText.destroy();
                    
                    // Clean up any existing game elements
                    if (this.tileGroup) {
                        this.tileGroup.clear(true, true);
                    }
                    if (this.scoreText) {
                        this.scoreText.destroy();
                    }
                    if (this.timerText) {
                        this.timerText.destroy();
                    }
                    if (this.timerBarContainer) {
                        this.timerBarContainer.destroy();
                    }
                    
                    // Go to splash screen instead of restarting
                    this.scene.start('SplashScene');
                });
            }
            
            createGrid(gridPadding) {
                // Calculate total grid width
                const totalWidth = this.gridSize * this.tileSize + (this.gridSize - 1) * this.padding;
                
                // Calculate starting position 
                const startX = gridPadding;
                const startY = (this.gameHeight - totalWidth) / 2;
                
                // Get a random compound pair that can be formed
                this.currentCompoundPair = IonDatabase.getRandomCompoundPair();
                const { cation, anion } = this.currentCompoundPair;
                const { cationCount, anionCount } = IonDatabase.getRequiredCounts(cation, anion);
                
                // Calculate how many tiles we need for each ion
                const totalIonTiles = cationCount + anionCount;
                
                // Create array of ions to place
                let ionsToPlace = [];
                for (let i = 0; i < cationCount; i++) {
                    ionsToPlace.push({ ...cation, type: 'cation' });
                }
                for (let i = 0; i < anionCount; i++) {
                    ionsToPlace.push({ ...anion, type: 'anion' });
                }
                
                // Fill remaining spaces with random ions that won't form compounds
                const remainingSpaces = this.gridSize * this.gridSize - totalIonTiles;
                for (let i = 0; i < remainingSpaces; i++) {
                    // Randomly choose between cation and anion
                    if (Math.random() < 0.5) {
                        const randomCation = IonDatabase.cations[Math.floor(Math.random() * IonDatabase.cations.length)];
                        ionsToPlace.push({ ...randomCation, type: 'cation' });
                    } else {
                        const randomAnion = IonDatabase.anions[Math.floor(Math.random() * IonDatabase.anions.length)];
                        ionsToPlace.push({ ...randomAnion, type: 'anion' });
                    }
                }
                
                // Shuffle the ions
                ionsToPlace = this.shuffleArray(ionsToPlace);
                
                // Create new tiles
                for (let row = 0; row < this.gridSize; row++) {
                    this.tiles[row] = [];
                    this.tileGraphics[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        const x = startX + col * (this.tileSize + this.padding) + this.tileSize / 2;
                        const y = startY + row * (this.tileSize + this.padding) + this.tileSize / 2;
                        
                        // Get the next ion from our shuffled array
                        const ion = ionsToPlace[row * this.gridSize + col];
                        
                        // Create graphics object for tile with rounded corners
                        const graphics = this.add.graphics();
                        
                        // Draw the tile with rounded corners
                        this.drawTile(graphics, x, y, this.tileColor, false);
                        
                        // Calculate optimal font size for this ion
                        const fontSize = this.calculateOptimalFontSize(ion.symbol);
                        
                        // Add ion symbol text with calculated font size
                        const text = this.add.text(x, y, ion.symbol, {
                            fontFamily: this.fontFamily,
                            fontSize: `${fontSize}px`,
                            fill: '#000000',
                            fontWeight: this.fontWeightBold
                        }).setOrigin(0.5);
                        
                        // Create interactive zone over the graphics
                        const tile = this.add.zone(
                            x, 
                            y, 
                            this.tileSize, 
                            this.tileSize
                        ).setInteractive();
                        
                        // Store ion data and text reference
                        tile.ion = ion;
                        tile.text = text;
                        tile.isSelected = false;
                        tile.isMatched = false;
                        tile.gridRow = row;
                        tile.gridCol = col;
                        
                        // Add click handler
                        tile.on('pointerdown', () => this.selectTile(tile, graphics));
                        
                        // Store the tile and its graphics in our arrays
                        this.tiles[row][col] = tile;
                        this.tileGraphics[row][col] = graphics;
                        
                        // Add to group for easy management
                        this.tileGroup.add(tile);
                        this.tileGroup.add(text);
                    }
                }
            }
            
            drawTile(graphics, x, y, color, selected) {
                // Clear existing graphics
                graphics.clear();
                
                if (selected) {
                    // Draw selected tile with highlight border
                    graphics.fillStyle(color);
                    graphics.fillRoundedRect(
                        x - this.tileSize / 2, 
                        y - this.tileSize / 2, 
                        this.tileSize, 
                        this.tileSize, 
                        8
                    );
                    
                    // Add cyan highlight border
                    graphics.lineStyle(4, this.highlightColor);
                    graphics.strokeRoundedRect(
                        x - this.tileSize / 2, 
                        y - this.tileSize / 2, 
                        this.tileSize, 
                        this.tileSize, 
                        8
                    );
                } else {
                    // Draw normal tile
                    graphics.fillStyle(color);
                    graphics.fillRoundedRect(
                        x - this.tileSize / 2, 
                        y - this.tileSize / 2, 
                        this.tileSize, 
                        this.tileSize, 
                        8
                    );
                }
            }
            
            createPauseButton() {
                // Create pause button in the top-right corner
                const buttonSize = 40;
                const padding = 10;
                
                // Create a perfect circle for the pause button
                this.pauseButton = this.add.circle(
                    this.gameWidth - padding - buttonSize/2,
                    padding + buttonSize/2,
                    buttonSize/2,
                    0x4caf50
                ).setInteractive();
                
                // Create pause icon (two vertical lines)
                const lineWidth = 4;
                const lineHeight = 15;
                const gap = 8; // Increased gap between lines from 4 to 8
                
                // Left line
                this.pauseLine1 = this.add.rectangle(
                    this.pauseButton.x - gap/2,
                    this.pauseButton.y,
                    lineWidth,
                    lineHeight,
                    0xffffff
                );
                
                // Right line
                this.pauseLine2 = this.add.rectangle(
                    this.pauseButton.x + gap/2,
                    this.pauseButton.y,
                    lineWidth,
                    lineHeight,
                    0xffffff
                );
                
                // Add hover effect
                this.pauseButton.on('pointerover', () => {
                    this.pauseButton.setFillStyle(0x66bb6a);
                });
                
                this.pauseButton.on('pointerout', () => {
                    if (!this.gameState.isPaused) {
                        this.pauseButton.setFillStyle(0x4caf50);
                    }
                });
                
                // Add click handler
                this.pauseButton.on('pointerdown', () => {
                    if (this.gameState.isPaused) {
                        this.resumeGame();
                    } else {
                        this.pauseGame();
                    }
                });
            }
            
            pauseGame() {
                // Set game state to paused
                this.gameState.isPaused = true;
                
                // Pause the timers
                if (this.gameTimer) {
                    this.gameTimer.paused = true;
                }
                if (this.progressTimer) {
                    this.progressTimer.paused = true;
                }
                
                // Change pause button color to indicate paused state
                this.pauseButton.setFillStyle(0xff9900);
                
                // Create pause overlay with 100% opacity black
                this.pauseOverlay = this.add.rectangle(
                    0, 0, 
                    this.gameWidth, 
                    this.gameHeight, 
                    0x000000, 
                    1.0
                ).setOrigin(0);
                
                // Display pause message
                this.pauseText = this.add.text(
                    this.gameWidth / 2,
                    this.gameHeight / 2 - 50,
                    'Game Paused',
                    { 
                        fontFamily: this.fontFamily,
                        fontSize: '40px',
                        fill: '#ffffff',
                        fontWeight: this.fontWeightBold
                    }
                ).setOrigin(0.5);
                
                // Create resume button
                this.resumeButton = this.add.rectangle(
                    this.gameWidth / 2,
                    this.gameHeight / 2 + 50,
                    180,
                    50,
                    0x4caf50
                ).setInteractive();
                
                this.resumeText = this.add.text(
                    this.gameWidth / 2,
                    this.gameHeight / 2 + 50,
                    'Resume',
                    { 
                        fontFamily: this.fontFamily,
                        fontSize: '24px',
                        fill: '#ffffff',
                        fontWeight: this.fontWeightBold
                    }
                ).setOrigin(0.5);
                
                // Add hover effect to resume button
                this.resumeButton.on('pointerover', () => {
                    this.resumeButton.setFillStyle(0x66bb6a);
                });
                
                this.resumeButton.on('pointerout', () => {
                    this.resumeButton.setFillStyle(0x4caf50);
                });
                
                // Add click handler to resume button
                this.resumeButton.on('pointerdown', () => {
                    this.resumeGame();
                });
                
                // Disable tile interactions
                this.tileGroup.getChildren().forEach(tile => {
                    if (tile.input) {
                        tile.disableInteractive();
                    }
                });
            }
            
            resumeGame() {
                // Set game state to not paused
                this.gameState.isPaused = false;
                
                // Resume the timers
                if (this.gameTimer) {
                    this.gameTimer.paused = false;
                }
                if (this.progressTimer) {
                    this.progressTimer.paused = false;
                }
                
                // Change pause button color back to normal
                this.pauseButton.setFillStyle(0x4caf50);
                
                // Remove pause overlay and elements
                if (this.pauseOverlay) this.pauseOverlay.destroy();
                if (this.pauseText) this.pauseText.destroy();
                if (this.resumeButton) this.resumeButton.destroy();
                if (this.resumeText) this.resumeText.destroy();
                
                // Re-enable tile interactions
                this.tileGroup.getChildren().forEach(tile => {
                    if (tile.input && !tile.isMatched) {
                        tile.setInteractive();
                    }
                });
            }
            
            selectTile(tile, graphics) {
                // Don't allow selection if game is paused
                if (this.gameState.isPaused) return;
                
                if (this.isProcessingMatch || tile.isMatched) return;
                
                // If trying to select more than 5 tiles, deselect all
                if (this.selectedTiles.length >= 5 && !tile.isSelected) {
                    this.deselectAllTiles();
                    return;
                }
                
                // If tile is already selected, deselect it
                if (tile.isSelected) {
                    tile.isSelected = false;
                    this.drawTile(graphics, tile.x, tile.y, this.tileColor, false);
                    const index = this.selectedTiles.indexOf(tile);
                    if (index > -1) {
                        this.selectedTiles.splice(index, 1);
                        this.gameState.currentSelection.splice(index, 1);
                    }
                    this.flowValidator.reset();
                    return;
                }
                
                // Validate the new selection against flow patterns
                const isValid = this.flowValidator.addSelection(tile.ion.charge);
                
                if (!isValid) {
                    // Invalid selection - show error and reset
                    this.handleInvalidSelection();
                    return;
                }
                
                // Valid selection - add to selected tiles
                tile.isSelected = true;
                this.drawTile(graphics, tile.x, tile.y, this.tileColor, true);
                this.selectedTiles.push(tile);
                this.gameState.currentSelection.push(tile.ion);
                
                // Update expected charges for next selection
                this.gameState.expectedCharges = this.flowValidator.getExpectedNextCharges();
                
                // Check if we have a complete valid flow
                if (this.flowValidator.isCompleteFlow()) {
                    this.validateCompound();
                }
            }
            
            determineCompoundType() {
                // Get unique ions and their counts
                const ionCounts = {};
                this.gameState.currentSelection.forEach(ion => {
                    const key = `${ion.symbol}_${ion.charge}`;
                    ionCounts[key] = (ionCounts[key] || 0) + 1;
                });
                
                // Get unique ions
                const uniqueIons = this.gameState.currentSelection.filter((ion, index, self) =>
                    index === self.findIndex(i => i.symbol === ion.symbol && i.charge === ion.charge)
                );
                
                if (uniqueIons.length !== 2) return;
                
                const [ion1, ion2] = uniqueIons;
                const count1 = ionCounts[`${ion1.symbol}_${ion1.charge}`];
                const count2 = ionCounts[`${ion2.symbol}_${ion2.charge}`];
                
                // Calculate total charges
                const totalCharge1 = ion1.charge * count1;
                const totalCharge2 = ion2.charge * count2;
                
                // Determine pattern based on total charges
                if (Math.abs(totalCharge1) === Math.abs(totalCharge2)) {
                    if (this.gameState.currentSelection.length === 2) {
                        this.compoundType = 'simple';
                        this.gameState.expectedIonCount = 2;
                    } else if (this.gameState.currentSelection.length === 3) {
                        this.compoundType = 'intermediate';
                        this.gameState.expectedIonCount = 3;
                    } else if (this.gameState.currentSelection.length === 5) {
                        this.compoundType = 'advanced';
                        this.gameState.expectedIonCount = 5;
                    }
                }
            }
            
            validateCompound() {
                this.isProcessingMatch = true;
                
                // Calculate net charge
                const netCharge = this.calculateNetCharge(this.selectedTiles);
                
                // If net charge is not zero, the combination is invalid
                if (netCharge !== 0) {
                    this.handleInvalidCompound();
                    return;
                }
                
                // Get unique ions and their counts
                const ionCounts = {};
                this.gameState.currentSelection.forEach(ion => {
                    const key = `${ion.symbol}_${ion.charge}`;
                    ionCounts[key] = (ionCounts[key] || 0) + 1;
                });
                
                // Get unique ions
                const uniqueIons = this.gameState.currentSelection.filter((ion, index, self) =>
                    index === self.findIndex(i => i.symbol === ion.symbol && i.charge === ion.charge)
                );
                
                if (uniqueIons.length !== 2) {
                    this.handleInvalidCompound();
                    return;
                }
                
                const [ion1, ion2] = uniqueIons;
                const count1 = ionCounts[`${ion1.symbol}_${ion1.charge}`];
                const count2 = ionCounts[`${ion2.symbol}_${ion2.charge}`];
                
                // Create compound key based on ion counts
                let compoundKey;
                if (ion1.charge > 0) { // ion1 is cation
                    compoundKey = `${ion1.symbol}_${ion2.symbol}`;
                } else { // ion1 is anion
                    compoundKey = `${ion2.symbol}_${ion1.symbol}`;
                }
                
                // Get compound name from database
                const compoundName = IonDatabase.compounds[compoundKey];
                
                if (compoundName) {
                    // Show MCQ with compound options
                    this.showMultipleChoice(compoundName);
                    
                    // Mark tiles as matched
                    this.selectedTiles.forEach(tile => {
                        tile.isMatched = true;
                        tile.setVisible(false);
                        if (tile.text) tile.text.setVisible(false);
                    });
                    
                    // Reset game state
                    this.resetGameState();
                } else {
                    this.handleInvalidCompound();
                }
                
                this.isProcessingMatch = false;
            }
            
            handleInvalidCompound() {
                // Store the tiles that need to be replaced
                const tilesToReplace = [...this.selectedTiles];
                
                // Animate tiles turning red
                this.selectedTiles.forEach(tile => {
                    const graphics = this.tileGraphics[tile.gridRow][tile.gridCol];
                this.tweens.add({
                        targets: graphics,
                        fillColor: 0xff0000,
                        duration: 200,
                        yoyo: true,
                    onComplete: () => {
                            // After red flash, destroy the tile and text
                            tile.setVisible(false);
                            if (tile.text) tile.text.setVisible(false);
                            
                            // Create new ion for this position with fade-in animation
                            this.createNewIonForTile(tile);
                        }
                    });
                });
                
                // Reset selection state but maintain flow validation
                this.selectedTiles = [];
                this.gameState.currentSelection = [];
                this.isProcessingMatch = false;
            }
            
            createNewIonForTile(tile) {
                // Get a random ion
                const randomIon = Math.random() < 0.5 
                    ? IonDatabase.cations[Math.floor(Math.random() * IonDatabase.cations.length)]
                    : IonDatabase.anions[Math.floor(Math.random() * IonDatabase.anions.length)];
                
                // Create new ion with type
                const newIon = { ...randomIon, type: randomIon.charge > 0 ? 'cation' : 'anion' };
                
                // Calculate optimal font size for the new ion
                const fontSize = this.calculateOptimalFontSize(newIon.symbol);
                
                // Create new text for the ion with calculated font size
                const text = this.add.text(tile.x, tile.y, newIon.symbol, {
                    fontFamily: this.fontFamily,
                    fontSize: `${fontSize}px`,
                    fill: '#000000',
                    fontWeight: this.fontWeightBold
                }).setOrigin(0.5).setAlpha(0); // Start with 0 alpha for fade-in
                
                // Update tile properties
                tile.ion = newIon;
                tile.text = text;
                tile.isSelected = false;
                tile.isMatched = false;
                tile.setVisible(true);
                
                // Draw the tile with initial alpha
                const graphics = this.tileGraphics[tile.gridRow][tile.gridCol];
                graphics.clear();
                this.drawTile(graphics, tile.x, tile.y, this.tileColor, false);
                graphics.setAlpha(0);
                
                // Add to group for management
                this.tileGroup.add(text);
                
                // Animate fade-in over 1000ms
                this.tweens.add({
                    targets: [graphics, text],
                    alpha: 1,
                    duration: 1000,
                    ease: 'Power2'
                });
            }
            
            handleInvalidSelection() {
                // This method is now only used for invalid flow patterns
                // Pulse tiles red to indicate invalid selection
                this.selectedTiles.forEach(tile => {
                    const graphics = this.tileGraphics[tile.gridRow][tile.gridCol];
                    this.tweens.add({
                        targets: graphics,
                        fillColor: 0xff0000,
                        duration: 200,
                        yoyo: true,
                    onComplete: () => {
                            this.drawTile(graphics, tile.x, tile.y, this.tileColor, false);
                        }
                    });
                });
                
                // Deselect all tiles after animation
                this.time.delayedCall(400, () => {
                    this.deselectAllTiles();
                });
            }
            
            resetGameState() {
                        this.selectedTiles = [];
                this.gameState.currentSelection = [];
                this.gameState.expectedIonCount = 0;
                this.gameState.expectedCharges = [];
                this.compoundType = null;
                this.flowValidator.reset();
            }
            
            deselectAllTiles() {
                this.selectedTiles.forEach(tile => {
                    tile.isSelected = false;
                    this.drawTile(this.tileGraphics[tile.gridRow][tile.gridCol], tile.x, tile.y, this.tileColor, false);
                });
                this.resetGameState();
            }
            
            // Helper function to calculate net charge of selected ions
            calculateNetCharge(selectedIons) {
                return selectedIons.reduce((total, tile) => total + tile.ion.charge, 0);
            }
            
            showMultipleChoice(correctCompound) {
                // Get three random incorrect compounds
                const incorrectCompounds = [];
                while (incorrectCompounds.length < 3) {
                    const randomPair = IonDatabase.getRandomCompoundPair();
                    const compound = IonDatabase.getCompoundName(randomPair.cation, randomPair.anion);
                    if (compound && compound !== correctCompound && !incorrectCompounds.includes(compound)) {
                        incorrectCompounds.push(compound);
                    }
                }
                
                // Ensure we have exactly 4 options (1 correct + 3 incorrect)
                if (incorrectCompounds.length < 3) {
                    // If we couldn't get enough unique compounds, add some default ones
                    const defaultCompounds = [
                        'Sodium chloride',
                        'Potassium hydroxide',
                        'Calcium carbonate',
                        'Magnesium sulfate',
                        'Aluminum oxide',
                        'Iron(III) chloride',
                        'Barium hydroxide',
                        'Silver nitrate',
                        'Ammonium chloride'
                    ];
                    
                    while (incorrectCompounds.length < 3) {
                        const randomCompound = defaultCompounds[Math.floor(Math.random() * defaultCompounds.length)];
                        if (randomCompound !== correctCompound && !incorrectCompounds.includes(randomCompound)) {
                            incorrectCompounds.push(randomCompound);
                        }
                    }
                }
                
                // Combine and shuffle options
                const options = [correctCompound, ...incorrectCompounds];
                this.shuffleArray(options);
                
                // Show MCQ card with options
                this.showMCQCard(options, correctCompound);
            }
            
            showMCQCard(options, correctCompound) {
                // Create semi-transparent background
                const overlay = this.add.rectangle(
                    this.gameWidth / 2,
                    this.gameHeight / 2,
                    this.gameWidth,
                    this.gameHeight,
                    0x000000,
                    0.7
                );
                
                // Calculate card dimensions and position
                const cardWidth = this.gameWidth - 40;
                const cardHeight = 500;
                const cardY = this.gameHeight / 2;
                
                // Create card background
                const card = this.add.rectangle(
                    this.gameWidth / 2,
                    cardY,
                    cardWidth,
                    cardHeight,
                    0xffffff
                ).setStrokeStyle(2, 0x000000);
                
                // Create title text
                const titleText = this.add.text(
                    this.gameWidth / 2,
                    cardY - cardHeight/2 + 30,
                    'Select the correct compound:',
                    {
                        fontFamily: this.fontFamily,
                        fontSize: '24px',
                        fill: '#000000',
                        fontWeight: this.fontWeightBold
                    }
                ).setOrigin(0.5);
                
                // Get the chemical formula from the CSV data
                let formula = '';
                // Find the formula from the selected ions
                const uniqueIons = this.gameState.currentSelection.filter((ion, index, self) =>
                    index === self.findIndex(i => i.symbol === ion.symbol && i.charge === ion.charge)
                );
                
                if (uniqueIons.length === 2) {
                    const [ion1, ion2] = uniqueIons;
                    
                    // Create compound key based on ion order (cation first, then anion)
                    let compoundKey;
                    if (ion1.charge > 0) { // ion1 is cation
                        compoundKey = `${ion1.symbol}_${ion2.symbol}`;
                    } else { // ion1 is anion
                        compoundKey = `${ion2.symbol}_${ion1.symbol}`;
                    }
                    
                    // Get the formula from the CSV data
                    // We need to find the row in the CSV that matches our compound
                    // For now, we'll use a mapping approach
                    const formulaMap = {
                        'Na⁺_OH⁻': 'NaOH',
                        'Na⁺_Cl⁻': 'NaCl',
                        'Na⁺_Br⁻': 'NaBr',
                        'Na⁺_I⁻': 'NaI',
                        'Na⁺_F⁻': 'NaF',
                        'Na⁺_NO₃⁻': 'NaNO₃',
                        'Na⁺_SO₄²⁻': 'Na₂SO₄',
                        'Na⁺_CO₃²⁻': 'Na₂CO₃',
                        'Na⁺_PO₄³⁻': 'Na₃PO₄',
                        'Na⁺_HCO₃⁻': 'NaHCO₃',
                        'Na⁺_O²⁻': 'Na₂O',
                        'Na⁺_S²⁻': 'Na₂S',
                        'Na⁺_CH₃COO⁻': 'CH₃COONa',
                        'K⁺_OH⁻': 'KOH',
                        'K⁺_Cl⁻': 'KCl',
                        'K⁺_Br⁻': 'KBr',
                        'K⁺_I⁻': 'KI',
                        'K⁺_F⁻': 'KF',
                        'K⁺_NO₃⁻': 'KNO₃',
                        'K⁺_SO₄²⁻': 'K₂SO₄',
                        'K⁺_CO₃²⁻': 'K₂CO₃',
                        'K⁺_PO₄³⁻': 'K₃PO₄',
                        'K⁺_HCO₃⁻': 'KHCO₃',
                        'K⁺_O²⁻': 'K₂O',
                        'K⁺_S²⁻': 'K₂S',
                        'K⁺_CH₃COO⁻': 'CH₃COOK',
                        'Li⁺_OH⁻': 'LiOH',
                        'Li⁺_Cl⁻': 'LiCl',
                        'Li⁺_Br⁻': 'LiBr',
                        'Li⁺_I⁻': 'LiI',
                        'Li⁺_F⁻': 'LiF',
                        'Li⁺_NO₃⁻': 'LiNO₃',
                        'Li⁺_SO₄²⁻': 'Li₂SO₄',
                        'Li⁺_CO₃²⁻': 'Li₂CO₃',
                        'Li⁺_PO₄³⁻': 'Li₃PO₄',
                        'Li⁺_O²⁻': 'Li₂O',
                        'Li⁺_S²⁻': 'Li₂S',
                        'Li⁺_CH₃COO⁻': 'CH₃COOLi',
                        'Mg²⁺_OH⁻': 'Mg(OH)₂',
                        'Mg²⁺_Cl⁻': 'MgCl₂',
                        'Mg²⁺_Br⁻': 'MgBr₂',
                        'Mg²⁺_I⁻': 'MgI₂',
                        'Mg²⁺_F⁻': 'MgF₂',
                        'Mg²⁺_NO₃⁻': 'Mg(NO₃)₂',
                        'Mg²⁺_SO₄²⁻': 'MgSO₄',
                        'Mg²⁺_CO₃²⁻': 'MgCO₃',
                        'Mg²⁺_PO₄³⁻': 'Mg₃(PO₄)₂',
                        'Mg²⁺_O²⁻': 'MgO',
                        'Mg²⁺_S²⁻': 'MgS',
                        'Mg²⁺_CH₃COO⁻': 'Mg(CH₃COO)₂',
                        'Ca²⁺_OH⁻': 'Ca(OH)₂',
                        'Ca²⁺_Cl⁻': 'CaCl₂',
                        'Ca²⁺_Br⁻': 'CaBr₂',
                        'Ca²⁺_I⁻': 'CaI₂',
                        'Ca²⁺_F⁻': 'CaF₂',
                        'Ca²⁺_NO₃⁻': 'Ca(NO₃)₂',
                        'Ca²⁺_SO₄²⁻': 'CaSO₄',
                        'Ca²⁺_CO₃²⁻': 'CaCO₃',
                        'Ca²⁺_PO₄³⁻': 'Ca₃(PO₄)₂',
                        'Ca²⁺_O²⁻': 'CaO',
                        'Ca²⁺_S²⁻': 'CaS',
                        'Ca²⁺_CH₃COO⁻': 'Ca(CH₃COO)₂',
                        'Al³⁺_OH⁻': 'Al(OH)₃',
                        'Al³⁺_Cl⁻': 'AlCl₃',
                        'Al³⁺_Br⁻': 'AlBr₃',
                        'Al³⁺_I⁻': 'AlI₃',
                        'Al³⁺_F⁻': 'AlF₃',
                        'Al³⁺_NO₃⁻': 'Al(NO₃)₃',
                        'Al³⁺_SO₄²⁻': 'Al₂(SO₄)₃',
                        'Al³⁺_PO₄³⁻': 'AlPO₄',
                        'Al³⁺_O²⁻': 'Al₂O₃',
                        'Al³⁺_S²⁻': 'Al₂S₃',
                        'Al³⁺_CH₃COO⁻': 'Al(CH₃COO)₃',
                        'Fe²⁺_OH⁻': 'Fe(OH)₂',
                        'Fe²⁺_Cl⁻': 'FeCl₂',
                        'Fe²⁺_Br⁻': 'FeBr₂',
                        'Fe²⁺_I⁻': 'FeI₂',
                        'Fe²⁺_F⁻': 'FeF₂',
                        'Fe²⁺_NO₃⁻': 'Fe(NO₃)₂',
                        'Fe²⁺_SO₄²⁻': 'FeSO₄',
                        'Fe²⁺_CO₃²⁻': 'FeCO₃',
                        'Fe²⁺_PO₄³⁻': 'Fe₃(PO₄)₂',
                        'Fe²⁺_O²⁻': 'FeO',
                        'Fe²⁺_S²⁻': 'FeS',
                        'Fe²⁺_CH₃COO⁻': 'Fe(CH₃COO)₂',
                        'Fe³⁺_OH⁻': 'Fe(OH)₃',
                        'Fe³⁺_Cl⁻': 'FeCl₃',
                        'Fe³⁺_Br⁻': 'FeBr₃',
                        'Fe³⁺_I⁻': 'FeI₃',
                        'Fe³⁺_F⁻': 'FeF₃',
                        'Fe³⁺_NO₃⁻': 'Fe(NO₃)₃',
                        'Fe³⁺_SO₄²⁻': 'Fe₂(SO₄)₃',
                        'Fe³⁺_PO₄³⁻': 'FePO₄',
                        'Fe³⁺_O²⁻': 'Fe₂O₃',
                        'Fe³⁺_S²⁻': 'Fe₂S₃',
                        'Fe³⁺_CH₃COO⁻': 'Fe(CH₃COO)₃',
                        'Ba²⁺_OH⁻': 'Ba(OH)₂',
                        'Ba²⁺_Cl⁻': 'BaCl₂',
                        'Ba²⁺_Br⁻': 'BaBr₂',
                        'Ba²⁺_I⁻': 'BaI₂',
                        'Ba²⁺_F⁻': 'BaF₂',
                        'Ba²⁺_NO₃⁻': 'Ba(NO₃)₂',
                        'Ba²⁺_SO₄²⁻': 'BaSO₄',
                        'Ba²⁺_CO₃²⁻': 'BaCO₃',
                        'Ba²⁺_PO₄³⁻': 'Ba₃(PO₄)₂',
                        'Ba²⁺_O²⁻': 'BaO',
                        'Ba²⁺_S²⁻': 'BaS',
                        'Ba²⁺_CH₃COO⁻': 'Ba(CH₃COO)₂',
                        'Ag⁺_Cl⁻': 'AgCl',
                        'Ag⁺_Br⁻': 'AgBr',
                        'Ag⁺_I⁻': 'AgI',
                        'Ag⁺_F⁻': 'AgF',
                        'Ag⁺_NO₃⁻': 'AgNO₃',
                        'Ag⁺_SO₄²⁻': 'Ag₂SO₄',
                        'Ag⁺_CO₃²⁻': 'Ag₂CO₃',
                        'Ag⁺_PO₄³⁻': 'Ag₃PO₄',
                        'Ag⁺_O²⁻': 'Ag₂O',
                        'Ag⁺_S²⁻': 'Ag₂S',
                        'Ag⁺_CH₃COO⁻': 'CH₃COOAg',
                        'NH₄⁺_OH⁻': 'NH₄OH',
                        'NH₄⁺_Cl⁻': 'NH₄Cl',
                        'NH₄⁺_Br⁻': 'NH₄Br',
                        'NH₄⁺_I⁻': 'NH₄I',
                        'NH₄⁺_F⁻': 'NH₄F',
                        'NH₄⁺_NO₃⁻': 'NH₄NO₃',
                        'NH₄⁺_SO₄²⁻': '(NH₄)₂SO₄',
                        'NH₄⁺_CO₃²⁻': '(NH₄)₂CO₃',
                        'NH₄⁺_PO₄³⁻': '(NH₄)₃PO₄',
                        'NH₄⁺_HCO₃⁻': 'NH₄HCO₃',
                        'NH₄⁺_O²⁻': '(NH₄)₂O',
                        'NH₄⁺_S²⁻': '(NH₄)₂S',
                        'NH₄⁺_CH₃COO⁻': 'NH₄CH₃COO'
                    };
                    
                    formula = formulaMap[compoundKey] || '';
                }
                
                // Display the formula
                const formulaText = this.add.text(
                    this.gameWidth / 2,
                    cardY - cardHeight/2 + 70,
                    `Chemical Formula: ${formula}`,
                    {
                        fontFamily: this.fontFamily,
                        fontSize: '20px',
                        fill: '#787878',
                        fontWeight: this.fontWeightNormal
                    }
                ).setOrigin(0.5);
                
                // Create option buttons
                const optionButtons = [];
                const optionTexts = [];
                const buttonWidth = cardWidth - 40;
                const buttonHeight = 60;
                const spacing = 20;
                
                // Calculate starting position to center the buttons
                const startX = this.gameWidth/2;
                const startY = cardY - 50;
                
                for (let i = 0; i < 4; i++) {
                    const y = startY + i * (buttonHeight + spacing);
                    
                    // Create button with white background
                    const button = this.add.rectangle(
                        startX,
                        y,
                        buttonWidth,
                        buttonHeight,
                        0xffffff
                    )
                    .setStrokeStyle(2, 0x000000)
                    .setInteractive();
                    
                    // Create text with proper styling and word wrap
                    const text = this.add.text(
                        startX,
                        y,
                        options[i],
                        {
                            fontFamily: this.fontFamily,
                            fontSize: '20px',
                            fill: '#000000',
                            fontWeight: this.fontWeightNormal,
                            wordWrap: { width: buttonWidth - 20 }
                        }
                    ).setOrigin(0.5);
                    
                    optionButtons.push(button);
                    optionTexts.push(text);
                    
                    // Add click handler
                    button.on('pointerdown', () => {
                        // Disable all buttons to prevent multiple clicks
                        optionButtons.forEach(btn => btn.disableInteractive());
                        
                        if (options[i] === correctCompound) {
                            // Highlight correct button with green background
                            button.setFillStyle(0x90EE90); // Light green
                            
                            // Update score
                            this.score += 10;
                            this.scoreText.setText(`Score: ${this.score}`);
                            
                            // Add a delay before starting the fade out
                            this.time.delayedCall(300, () => {
                                // Fade out animation
                                this.tweens.add({
                                    targets: [card, titleText, formulaText, ...optionButtons, ...optionTexts, overlay],
                                    alpha: 0,
                                    duration: 500,
                                    ease: 'Power2',
                                    onComplete: () => {
                                        // Clean up
                                        card.destroy();
                                        titleText.destroy();
                                        formulaText.destroy();
                                        optionButtons.forEach(btn => btn.destroy());
                                        optionTexts.forEach(txt => txt.destroy());
                                        overlay.destroy();
                                        
                                        // Replace matched tiles with new ones
                                        this.selectedTiles.forEach(tile => {
                                            tile.isMatched = true;
                                            tile.setVisible(false);
                                            if (tile.text) tile.text.setVisible(false);
                                        });
                                        
                                        // Replace with new tiles using fade in
                                        this.replaceTilesWithFade();
                                    }
                                });
                            });
                        } else {
                            // Wrong answer handling
                            button.setFillStyle(0xff6b6b); // Light red for wrong answer
                            
                            // Shake animation
                            this.tweens.add({
                                targets: [button, text],
                                x: button.x + 10,
                                duration: 50,
                                yoyo: true,
                                repeat: 3,
                                onComplete: () => {
                                    // Reset button color and re-enable all buttons
                                    button.setFillStyle(0xffffff);
                                    optionButtons.forEach(btn => btn.setInteractive());
                                }
                            });
                        }
                    });
                    
                    // Add hover effect (for desktop)
                    button.on('pointerover', () => {
                        if (button.input.enabled) {  // Only show hover effect if button is interactive
                            button.setFillStyle(0xf0f0f0);
                        }
                    });
                    
                    button.on('pointerout', () => {
                        if (button.input.enabled) {  // Only reset color if button is interactive
                            button.setFillStyle(0xffffff);
                        }
                    });
                }
            }
            
            replaceTilesWithFade() {
                // Get matched tiles
                const matchedTiles = this.tiles.flat().filter(tile => tile.isMatched);
                
                // For each matched tile, create a new one
                matchedTiles.forEach(tile => {
                    // Get a random ion
                    const randomIon = Math.random() < 0.5 
                        ? IonDatabase.cations[Math.floor(Math.random() * IonDatabase.cations.length)]
                        : IonDatabase.anions[Math.floor(Math.random() * IonDatabase.anions.length)];
                    
                    // Create new ion with type
                    const newIon = { ...randomIon, type: randomIon.charge > 0 ? 'cation' : 'anion' };
                    
                    // Calculate optimal font size for the new ion
                    const fontSize = this.calculateOptimalFontSize(newIon.symbol);
                    
                    // Create new text for the ion with calculated font size
                    const text = this.add.text(tile.x, tile.y, newIon.symbol, {
                        fontFamily: this.fontFamily,
                        fontSize: `${fontSize}px`,
                        fill: '#000000',
                        fontWeight: this.fontWeightBold
                    }).setOrigin(0.5);
                    
                    // Update tile properties
                    tile.ion = newIon;
                    tile.text = text;
                    tile.isSelected = false;
                    tile.isMatched = false;
                    tile.setVisible(true);
                    
                    // Draw the tile
                    const graphics = this.tileGraphics[tile.gridRow][tile.gridCol];
                    graphics.clear();
                    this.drawTile(graphics, tile.x, tile.y, this.tileColor, false);
                    
                    // Add to group for management
                    this.tileGroup.add(text);
                });
                
                // Reset match processing flag
                this.isProcessingMatch = false;
                // Clear selected tiles array
                this.selectedTiles = [];
            }
            
            // Helper function to shuffle an array
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
            
            // Add new method to calculate optimal font size
            calculateOptimalFontSize(symbol) {
                // Define length thresholds and corresponding font sizes
                const lengthThresholds = [
                    { length: 4, size: this.baseFontSize },    // For symbols like Na⁺, Cl⁻
                    { length: 6, size: 18 },                   // For symbols like Mg²⁺, SO₄²⁻
                    { length: 8, size: 16 },                   // For symbols like Al³⁺, PO₄³⁻
                    { length: 10, size: this.minFontSize }     // For symbols like CH₃COO⁻
                ];
                
                // Find the appropriate font size based on symbol length
                for (const threshold of lengthThresholds) {
                    if (symbol.length <= threshold.length) {
                        return threshold.size;
                    }
                }
                
                // Default to minimum font size for very long symbols
                return this.minFontSize;
            }
        }

        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: 390,
            height: 667,
            parent: 'game-container',
            scale: {
                mode: Phaser.Scale.EXPAND,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            scene: [SplashScene, MainScene],
            backgroundColor: '#000000'
        };

        // Initialize the game
        const game = new Phaser.Game(config);
        
        // Handle resize events
        window.addEventListener('resize', function() {
            if (game.scale) {
                game.scale.refresh();
            }
        });
    </script>
</body>
</html>
